<!doctype html><html><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0,maximum-scale=1" name=viewport><title>Curriculum Vitae di Domenico Alessio Cirasino</title><link href=https://www.shurizzle.dev/cv.css rel=stylesheet><link href=//cdn.jsdelivr.net/npm/hack-font@3/build/web/hack.css rel=stylesheet><body><main><div class=box><div class=wrap><header><div class=page-title><h1>Domenico Cirasino</h1><div class=personal-info><p><time datetime=1991-09-19>19/09/1991</time><p>Carovigno (BR)</div></div><div><a href=mailto:me@shurizzle.dev>/me@shurizzle.dev</a><a href=https://www.linkedin.com/in/domenico-cirasino-7225333b>/domenico-cirasino</a><a href=https://www.github.com/shurizzle>/shurizzle</a></div></header><section><h2>Istruzione</h2><div><div class=heading-line><h3>Diploma di maturità</h3><h3>2004-2010</h3></div><p><em>I.T.I.S. Enrico Pantanelli sez. Informatica, Ostuni.</em></div><div><div class=heading-line><h3>Autodidatta</h3><h3>2006-Oggi</h3></div><p>Il mio percorso è initiziato seguendo i primi tutorial sulla programmazione dal famoso <a href=https://www.html.it/>html.it</a>. In seguito ho cominciato a leggere libri, tra quelli che più mi hanno formato ci sono <a href=https://mitpress.mit.edu/sites/default/files/sicp/index.html> Structure and Interpretation of Computer Programs</a> e <a href=https://en.wikipedia.org/wiki/The_C_Programming_Language>The C Programming Language</a>.<p>Ho seguito molti corsi del sito Coursera e attraverso la rete ho trovato sempre più informazioni tramite libri e documentazioni tecniche. Tra i vari siti web che mi sono stati più utili ci sono <a href=https://github.com/>Github</a> e <a href=https://www.ycombinator.com/>Hacker News</a>, da lì ho studiato il codice e trovato novità a me fino a quel momento sconosciute. In seguito ho contribuito quanto possibile a progetti FOSS.</div></section><section><h2>Esperienze lavorative</h2><div><div class=heading-line><h3>Developer</h3><h3>2015-2015</h3></div></div><p><em> Presso RGI Group per Application Management di Gruppo Cattolica, Verona (VR). </em><p>Ho coperto il ruolo di programmatore. È stata la mia prima vera esperienza lavorativa, qui ho imparato la pazienza, soprattutto nell'essere un fornitore, in più il metodo e la disciplina nel lavoro oltre che a lavorare con un team notevolmente grande. Ho lavorato su un software basato su framework proprietari usando come linguaggi JavaScript e Java 5, come DBMS ho imparato ad usare Oracle, che fino a quel momento non avevo ancora avuto la possibilità di studiare. Per la gestione del codice usavamo SVN e un bug tracker per la sincronizzazione interna del lavoro.<div><div class=heading-line><h3>CTO</h3><h3>2015-2019</h3></div></div><p><em> Presso Interaktive Srl. Ho coperto principalmente le mansioni di System Admin, Software Engineer e Analyst, Sviluppatore. Moncalieri (TO). </em><p>In questa esperienza lavorativa ho imparato a prendere delle decisioni intelligenti sulla base delle variabili in gioco e a gestire un piccolo team, quindi ad avere delle responsabilità maggiori. Ho dovuto imbastire da zero un reparto che non era ancora esistente cercando di mediare tra l'aspetto funzionale e quello tecnico, tra la passione e la ragione. Ho studiato e applicato il metodo SCRUM aiutandomi con una kanban virtuale, la famosa piattaforma Trello. Come sistema di gestione del codice e diversionamento ho utilizzato GIT che avevo già interiorizzato in precedenza nei miei progetti personali. In team abbiamo sviluppato più microservizi facenti parte di un unico grande ecosistema centralizzato in un core project. I linguaggi che ho scelto di utilizzare sono stati Java 8, PHP 7.3, JavaScript, HTML e CSS. Ho lavorato a plugin per la piattaforma WordPress per l'interazione col core service. I vari framework utilizzati sono stati Laravel e Lumen, principalmente per la parte di amministrazione della piattaforma e microservizi secondari. Per alcune web app ho utilizzato il framework React.js in quanto più adeguato al ruolo che doveva ricoprire. Il core service constava di due parti principali, la parte del web service in Vert.x, un framework basato su Java 8, e la parte batch, con un framework proprietario, per ragioni di flessibilità. Come DBMS principale ho utilizzato PostgreSQL e ho utilizzato estensivamente il linguaggio PLPGSQL. Avendo assunto alcuni junior ho utilizzato la tecnica del pair programming per insegnare e cercare di capire dove sarebbero pottuti esserci degli intoppi. Per i server abbiamo scelto una soluzione in cloud unmanaged per via di un'estrema flessibilità.<div><div class=heading-line><h3>CTO</h3><h3>2020-2023</h3></div></div><p><em> Presso <a href=https://www.slymetrix.com/>Slymetrix Srl</a>. Ho coperto le mansioni di DevOps, Cloud Native Software Engineer e Analyst, Sviluppatore. Roma (RM). </em><p>In questa esperienza lavorativa ho scoperto il mondo delle startup, quindi la flessibilità che un software deve avere e l'importanza di una solida progettazione oltre che a lavorare pienamente in cloud. Abbiamo creato un nuovo prodotto sul mercato italiano che si occupa di tracciare spese e ricavi degli ecommerce mettendoli in relazione tra multipli canali per suggerire all'utente la via migliore da intraprendere su una progettazione annuale del budget. Qui, insieme al team, abbiamo sperimentato la pressione di vivere in una startup ma al momento stesso divertirsi lavorando per noi, per un progetto comune. Le tecnologie utilizzate sono tutte basate su Google Cloud Platform, una piattaforma di cloud computing. Il progetto consta di 3 parti principali tecnicamente slegate tra di loro che offrono l'intera esperienza utente: vetrina, academy e analytics, ma il business è concentrato sulla parte di analytics. Qui ho imparato ad utilizzare pienamente tecnologie come Google Cloud Functions, delle funzioni in cloud che vengono eseguite a seguito di eventi, scritte in nodejs. Il cruscotto è scritto in PHP 7.3 col framework Laravel e si occupa di prendere i dati da un DB PostgreSQL (Google Cloud SQL) e visualizzarli all'utente sotto forma di tabelle e grafici oltre che a rendere possibile all'utente la personalizzazione dei dati e della loro visualizzazione. Come metodo di persistenza utilizziamo principalmente PostgreSQL ma abbiamo sperimentato in passato anche una visualizzazione dei dati tramite Google Data Studio sviluppando un Google Data Source basato su Google BigQuery oltre Memcache per gestire sessioni e cache. Questo cruscotto attualmente funziona su Google Cloud Run, un layer di astrazione di Kubernetes che gestisce autonomamente il carico. Gli eventi viaggiano un un Pub/Sub e attivano le varie funzioni in background quando sono lanciati. La persistence dei file statici è gestita attraverso Google Cloud Storage, insieme ai file statici che permettono all'applicativo di funzionare. Il tutto dietro a Google Cloud Load Balancing che ci permette di instradare le richieste verso i giusti endpoint. Grazie a tutto lo studio e alla scelta di queste tecnologie siamo riusciti ad avere un uptime del 100% che nel caso specifico era essenziale. Siamo inoltre riusciti a integrarci direttamente con Google Tag Manager attraverso lo sviluppo di un template definito da noi. Un'altra skill che ho sviluppato in questo progetto è la produzione di metriche e l'analisi di esse, essenziale oltre che per il monitoraggio del corretto funzionamento del software anche all'ammortizzazione dei costi.</section><section><h2>tl;dr</h2><div><div class=heading-line><h3>Cosa mi piace utilizzare</h3></div></div><ul><li><strong>Rust</strong> <em>Perfomante come C, astratto come pochi.</em> <p>Permette una programmazione safe con delle altissime prestazioni e un livello di astrazione all'altezza di un linguaggio moderno. Interessante in microservizi che necessitano di alte prestazioni e affidabilità.</p><li><strong>neovim</strong> <em>Editor</em> <p>Estrema personalizzazione e flessibilità, ottime prestazioni e minimo consumo di risorse. Ottimi movimenti da tastiera essendo un editor modale.</p><li><strong>Arch Linux</strong> <em>Sistema Operativo</em> <p>Tutti i software che scrivo vanno a finire su un server Linux, perché non utilizzarlo anche sul desktop? Offre la massima personalizzazione e flessibilità, ideale per sviluppare software.</p><li><strong>Docker</strong> <em>Container and deployment system</em> <p>Ormai standard de facto nello sviluppo di applicativi cloud native e non. Utilizzo Docker Desktop quando mi trovo su MacOS e Windows così posso portarmi dietro tutto l'ambiente. Ormai indispensabile per me in accoppiata con docker-compose, che ora integra. Perfetto per creare degli ambienti di sviluppo che partono e si configurano con uno schiocco di dita.</p><li><strong>PostgreSQL</strong> <em>DBMS</em> <p>Dal mio punto di vista il miglior database relazionale al momento. Mi permette di scegliere con una granularità quasi atomica qualsiasi cosa nel database, dalla generazione di tipi custom agli indici. Mi è sempre stato utile nei software di analisi. Grazie al suo linguaggio PLPGSQL è capace di fare qualsiasi cosa con una rapidità estrema.</p></ul><div><div class=heading-line><h3>Cosa ho utilizzato</h3></div></div><ul><li><strong>Editor</strong> <em> Intellij Idea (android-studio), XCode, Atom, Visual Studio, Eclipse </em><li><strong>Linguaggi</strong> <em> Erlang, Elixir, Perl, C (89, 99, 11), C++, Assembly (8086), C#, Haskell, Scheme, Prolog, sh (bash, zsh), Python, F# </em></ul><div><div class=heading-line><h3>Cosa so utilizzare</h3></div></div><ul><li><strong>Google Cloud Platform</strong> <em>Piattaforma di Cloud Computing</em> <p>Functions, SQL, Run, Memstore, BigQuery, Compute Engine, Storage, Pub/Sub, Build, Cloud Balancing, StackDriver</p><li><strong>Google Tag Manager</strong> <em>Manager di tag</em> <p>Oltre all'utilizzo del tool in sè ho sviluppato anche un template per l'integrazione automatica di Slymetrix Analytics.</p><li><strong>PHP (5, 7, 8)</strong> <p>Utilizzato principalmente in accoppiata con Lumen/Laravel</p><li><strong>Java (4-21)</strong> <p>J2ME, J2EE, Spring e Vert.x.</p><li><strong>Go</strong> <p>Perfetto per creare microservizi performanti in GCP.</p><li><strong>Node.js/Typescript</strong> <p>Principalmente sotto forma di Typescript. Utilizzato per frontend con React.js e Webpack e Vite come bundler. Lato server con express.js e next.js e con Google Cloud Functions.</p><li><strong>Ruby</strong> <p>Utilizzo giornaliero per automatizzare i task. In passato l'ho utilizzato con Rails e Sinatra.</p><li><strong>Lua/Fennel</strong> <p>Utilizzato principalmente per le personalizzazioni del software come in neovim.</p><li><strong>HTML5/CSS3</strong> <p>Con framework come Bootstrap e Tailwind, ma spesso barebone visto l'uso di uikit che implementano già la maggior parte della grafica.</p><li><strong>vscode</strong> <p>Editor pronto all'uso, ideale per il pair programming.</p><li><strong>DBMS</strong> <p>Oracle, MySQL, MariaDB, Google BigQuery, MongoDB</p><li><strong>Key/Value store</strong> <p>Redis, Memcache, RocksDB.</p><li><strong>Sistemi operativi</strong> <p>Linux (Debian, Ubuntu, Arch, Gentoo/Funtoo), Windows (con WSL2), MacOS</p></ul></section><footer><p>Autorizzo il trattamento dei dati personali presenti nel CV ai sensi del D.Lgs. 2018/101 e del GDPR (Regolamento UE 2016/679).</footer></div></div></main>